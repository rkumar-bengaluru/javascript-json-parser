{"version":3,"sources":["webpack://RJsonParser/webpack/universalModuleDefinition","webpack://RJsonParser/./src/css/style.css","webpack://RJsonParser/./src/app.js","webpack://RJsonParser/./src/io/StringReader.js","webpack://RJsonParser/./src/json/JsonFormat.js","webpack://RJsonParser/./src/json/JsonLexer.js","webpack://RJsonParser/./src/json/JsonParser.js","webpack://RJsonParser/./src/json/JsonToken.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;ACVA;;;;;;;;;;;;;;;ACA0C;AACR;;AAElC;;AAEA;AACA;AACA,uBAAuB,qDAAU;AACjC,iCAAiC,eAAe;AAChD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACfe;;AAEf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;;ACxBqC;;AAEtB;;AAEf;AACA,eAAe,0DAAoB;AACnC;AACA;;;;;;;;;;;;;;;;;;ACRoC;AACS;;AAE9B;;AAEf;AACA;AACA;AACA;AACA,yBAAyB;AACzB,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,2BAA2B,qDAAY;AACvC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS,0BAA0B;AACnC;AACA,SAAS,0BAA0B;AACnC;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT,kFAAkF;AAClF,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,+CAAS;AAC5B;;AAEA;AACA;;AAEA;AACA;;AAEA,uBAAuB,YAAY;AACnC;AACA,4FAA4F,wFAAwF;AACpL;;AAEA;AACA;;AAEA,mBAAmB,+CAAS;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,mBAAmB,+CAAS;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C;AAC9C,gBAAgB,oBAAoB;AACpC,QAAQ,oBAAoB,UAAU,oBAAoB;AAC1D;AACA;AACA,iBAAiB,WAAW;AAC5B,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5RoC;;AAErB;;AAEf;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;;AAEA;AACA,+CAA+C;AAC/C,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;;AAEA,6BAA6B;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,+CAAS;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA,C;;;;;;;;;;;;;;;ACrGe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB,qBAAqB,oBAAoB;;AAEzC,iBAAiB,oBAAoB;AACrC,uBAAuB,sBAAsB;;AAE7C,gBAAgB,mBAAmB;AACnC,qBAAqB,oBAAoB;;AAEzC,kBAAkB,qBAAqB;AACvC,yBAAyB,wBAAwB;AACjD,C","file":"app.17b5e3582f28858ddedf.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"RJsonParser\"] = factory();\n\telse\n\t\troot[\"RJsonParser\"] = factory();\n})(this, function() {\nreturn ","// extracted by mini-css-extract-plugin\nexport {};","import JsonFormat from \"./json/JsonFormat\"\r\nimport css from \"./css/style.css\";\r\n\r\nparse();\r\n\r\nfunction parse() {\r\n    try {\r\n        let json = new JsonFormat();\r\n        //var res = json.parse('{\"rupak\":\"abcd\"}')\r\n        //console.log(res);\r\n        //document.getElementById('root').innerHTML = res;\r\n    } catch (e) {\r\n        console.error(e);\r\n        document.getElementById('root').innerHTML = e.message;\r\n    }\r\n}\r\n\r\n","export default class StringReader {\r\n\r\n    constructor(input) {\r\n        this._input = input;\r\n        this._length = this._input.length;\r\n        this._next = 0;\r\n        this._mark = 0;\r\n    }\r\n\r\n    _ensureOpen() {\r\n        if(this._input === null)\r\n            throw new Error(\"Stream closed\");\r\n    }\r\n\r\n    /*\r\n     Reads a single character.\r\n\r\n     @return -1, if the end of stream has reached.\r\n    */\r\n    read() {\r\n        this._ensureOpen();\r\n        if (this._next >= this._length)\r\n            return -1;\r\n        return this._input[this._next++];\r\n    }\r\n}","\r\nimport JsonParser from './JsonParser'\r\n\r\nexport default class JsonFormat {\r\n\r\n    parse(input) {\r\n        return JsonParser.runParser(input, null);\r\n    }\r\n}\r\n","import JsonToken from \"./JsonToken\";\r\nimport StringReader from \"../io/StringReader\"\r\n\r\nexport default class JsonLexer {\r\n\r\n    constructor(input, src) {\r\n        this._input = input;\r\n        this._src = src;\r\n        this._tokenTypes = {\r\n            openBrace: '{',\r\n            closeBrace: '}',\r\n            openBracket: '[',\r\n            closeBracket: ']',\r\n            colon: ':',\r\n            comma: ',',\r\n            stringValue: \"\",\r\n            integerValue: 0,\r\n            floatValue: 0.0,\r\n            trueValue: 'true',\r\n            falseValue: 'false',\r\n            nullValue: 'null',\r\n            endOfFile: 'EOF'\r\n        }\r\n        this._currentLine = 1;\r\n        this._currentColumn = 0;\r\n\r\n        this._tokenWriter = [];\r\n\r\n        this._tokenLine = -1;\r\n        this._tokenColumn = -1;\r\n\r\n        this._reader = new StringReader(this._input);\r\n        this._nextChar = this.readChar();\r\n        this._nextToken = this.readToken();\r\n    }\r\n\r\n    get tokenTypes() {\r\n        return this._tokenTypes;\r\n    }\r\n\r\n    readToken() {\r\n        while (true) {\r\n            if (this.testChar(' ') || this.testChar('\\t') || this.testChar('\\n') || this.testChar('\\r')) {\r\n                // Parse white space.\r\n                this.useChar();\r\n            } else if (this.testChar('/')) {\r\n                // Parse comments.\r\n                this.useChar();\r\n\r\n                if (this.testChar('/')) {\r\n                    this.useChar();\r\n\r\n                    while (!(this.testChar('\\n') || this.isEOF())) {\r\n                        this.useChar();\r\n                    }\r\n                } else if (this.testChar('*')) {\r\n                    this.useChar();\r\n\r\n                    while (!this.testChar('*')) {\r\n                        if (this.isEOF()) {\r\n                            throw new Error(\"Invalid comment\");\r\n                        }\r\n\r\n                        this.useChar();\r\n                    }\r\n\r\n                    this.useChar();\r\n\r\n                    while (this.testChar('*')) {\r\n                        this.useChar();\r\n                    }\r\n\r\n                    if (!this.testChar('/')) {\r\n                        throw new Error(\"Invalid comment\");\r\n                    }\r\n\r\n                    this.useChar();\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (this.testChar(',')) {\r\n            return this.singleCharToken(this._tokenTypes.comma);\r\n        } else if (this.testChar(':')) {\r\n            return this.singleCharToken(this._tokenTypes.colon);\r\n        } else if (this.testChar('{')) {\r\n            return this.singleCharToken(this._tokenTypes.openBrace);\r\n        } else if (this.testChar('}')) {\r\n            return this.singleCharToken(this._tokenTypes.closeBrace);\r\n        } else if (this.testChar('[')) {\r\n            return this.singleCharToken(this._tokenTypes.openBracket);\r\n        } else if (this.testChar(']')) {\r\n            return this.singleCharToken(this._tokenTypes.closeBracket);\r\n        } else if (this.testChar('t')) {\r\n            return this.keywordToken(this._tokenTypes.trueValue, \"true\");\r\n        } else if (this.testChar('f')) {\r\n            return this.keywordToken(this._tokenTypes.falseValue, \"false\");\r\n        } else if (this.testChar('n')) {\r\n            return this.keywordToken(this._tokenTypes.nullValue, \"null\");\r\n        } else if (this.testChar('0', '9') || this.testChar('-')) {\r\n            this.startToken();\r\n            this.useChar();\r\n\r\n            while (this.testChar('0', '9') || this.testChar('.') || this.testChar('e') || this.testChar('E') || this.testChar('-') || this.testChar('+')) {\r\n                this.useChar();\r\n            }\r\n\r\n            // Cannot use the patters to find the match directly because we are reading from a Reader and not a CharSequence.\r\n            if (integralPattern.matcher(getMatch()).matches()) {\r\n                return this.finishToken(this._tokenTypes.integralValue);\r\n            } else if (floatingPattern.matcher(getMatch()).matches()) {\r\n                return this.finishToken(this._tokenTypes.floatingValue);\r\n            } else {\r\n                throw createParseException(\"Invalid number\");\r\n            }\r\n        } else if (this.testChar('\\\"')) {\r\n            // \"((?:[^\\\\\"]|\\\\.)*)\"\r\n            this.startToken();\r\n            this.useChar();\r\n\r\n            while (!this.testChar('\\\"')) {\r\n                if (this.isEOF()) {\r\n                    var message = \"EOF inside string\";\r\n                    throw createParseException(message);\r\n                }\r\n\r\n                if (this.testControlChar()) {\r\n                    throw createParseException(\"Invalid control character\");\r\n                }\r\n\r\n                if (this.testChar('\\\\')) {\r\n                    this.useChar();\r\n                }\r\n\r\n                this.useChar();\r\n            }\r\n\r\n            this.useChar();\r\n\r\n            return this.finishToken(this._tokenTypes.stringValue);\r\n        } else if (this.isEOF()) {\r\n            return new Token(TokenType.endOfFile, \"\", currentLine, currentColumn); // meaning there are no more tokens\r\n        } else if (this.testControlChar()) {\r\n            throw this.createParseException(\"Invalid control character\");\r\n        } else {\r\n            console.log('invalid token....');\r\n            throw this.createParseException(this._currentLine,this._currentColumn,\"Invalid Token @Line \" + this._currentLine + \", @column \" + this._currentColumn);\r\n        }\r\n    }\r\n\r\n    readChar() {\r\n        return this._reader.read();\r\n    }\r\n\r\n    testToken(type) {\r\n        var res = this._nextToken.type === type;\r\n        console.log('_nextToken-' + this._nextToken.type + ', input->' + type + ',res-' + res);\r\n        console.log('_nextToken.line-' + this._nextToken.line + ', _nextToken.column->' + this._nextToken.column );\r\n        return this._nextToken.type === type;\r\n    }\r\n\r\n    createParseException(message) {\r\n        console.log(message);\r\n        return new Error('1234');\r\n    }\r\n\r\n    createTokenParseException(token, message) {\r\n        return this.createParseException(token.line, token.column, message);\r\n    }\r\n\r\n    createParseException(line, column, message) {\r\n        var instance = new Error(message, line, column);\r\n        return instance;\r\n    }\r\n\r\n    useToken() {\r\n        let res = this._nextToken;\r\n        this._nextToken = this.readToken();\r\n        return res;\r\n    }\r\n\r\n    useChar() {\r\n        if (this._nextChar === -1)\r\n            throw new Error('assertion failed.');\r\n\r\n        var res = this._nextChar;\r\n\r\n        if (this._nextChar === '\\n') {\r\n            this._currentLine += 1;\r\n            this._currentColumn = 0;\r\n        } else {\r\n            this._currentColumn += 1;\r\n        }\r\n\r\n        if (this._tokenWriter != null) {\r\n            this._tokenWriter.push(res);\r\n        }\r\n\r\n        this._nextChar = this.readChar();\r\n\r\n        return res;\r\n    }\r\n\r\n    testChar(character) {\r\n        return this._nextChar === character;\r\n    }\r\n\r\n    singleCharToken(type) {\r\n        var line = this._currentLine;\r\n        var column = this._currentColumn;\r\n\r\n        return new JsonToken(type, this._valueOf(this.useChar()), line, column);\r\n    }\r\n\r\n    _keywordToken(type, keyword) {\r\n        var length = keyword.length();\r\n\r\n        // we skip testing the first character as we wouldn't be here it it didn't match\r\n        useChar();\r\n\r\n        for (var i = 1; i < length; i += 1) {\r\n            if (!this.testChar(keyword.charAt(i))) {\r\n                throw createParseException(currentLine, currentColumn - i, \"Invalid token\"); // i hope we're safe with `currentColumn - i', multi-line keywords aren't that common ;-)\r\n            }\r\n\r\n            this.useChar();\r\n        }\r\n\r\n        return new JsonToken(type, keyword, currentLine, currentColumn - length);\r\n    }\r\n\r\n    _valueOf(input) {\r\n        return (input == null) ? \"null\" : '\\\"' + input + '\\\"';\r\n    }\r\n\r\n    startToken() {\r\n        this._tokenWriter = [];\r\n        this._tokenLine = this._currentLine;\r\n        this._okenColumn = this._currentColumn;\r\n    }\r\n\r\n    finishToken(type) {\r\n        let match = this.getMatch();\r\n\r\n        this._tokenWriter = null;\r\n\r\n        return new JsonToken(type, match, this._tokenLine, this._tokenColumn);\r\n    }\r\n\r\n    getMatch() {\r\n        return this._tokenWriter.toString();\r\n    }\r\n\r\n    isEOF() {\r\n\t\treturn this._nextChar === -1;\r\n\t}\r\n\r\n    testControlChar() {\r\n\t\treturn this.isISOControl(this._nextChar);\r\n\t}\r\n\r\n    /**\r\n     * Determines if the referenced character (Unicode code point) is an ISO control\r\n     * character.  A character is considered to be an ISO control\r\n     * character if its code is in the range {@code '\\u005Cu0000'}\r\n     * through {@code '\\u005Cu001F'} or in the range\r\n     * {@code '\\u005Cu007F'} through {@code '\\u005Cu009F'}.\r\n     *\r\n     * @param   codePoint the character (Unicode code point) to be tested.\r\n     * @return  {@code true} if the character is an ISO control character;\r\n     *          {@code false} otherwise.\r\n     * @see     Character#isSpaceChar(int)\r\n     * @see     Character#isWhitespace(int)\r\n     * @since   1.5\r\n     */\r\n     isISOControl( codePoint) {\r\n        // Optimized form of:\r\n        //     (codePoint >= 0x00 && codePoint <= 0x1F) ||\r\n        //     (codePoint >= 0x7F && codePoint <= 0x9F);\r\n        return codePoint <= 0x9F &&\r\n            (codePoint >= 0x7F || (codePoint >>> 5 == 0));\r\n    }\r\n}\r\n","import JsonLexer from \"./JsonLexer\";\r\n\r\nexport default class JsonParser {\r\n\r\n    constructor(lexer) {\r\n        this._lexer = lexer;\r\n    }\r\n\r\n    parseString(token) {\r\n        var res = [];\r\n        var string = token.match;\r\n        var pos = 1; // skip leading \"\r\n        var length = string.length - 1; // skip trailing \"\r\n        while (pos < length) {\r\n            if (string[pos] === '\\\\') {\r\n                let ch = string[pos + 1];\r\n                pos += 2;\r\n                if (ch === '\"') {\r\n                    res.push('\"');\r\n                } else if (ch === '\\\\') {\r\n                    res.push('\\\\');\r\n                } else if (ch === '/') {\r\n                    res.push('/');\r\n                } else if (ch === 'b') {\r\n                    res.push('\\b');\r\n                } else if (ch === 'f') {\r\n                    res.push('\\f');\r\n                } else if (ch === 'n') {\r\n                    res.push('\\n');\r\n                } else if (ch === 'r') {\r\n                    res.push('\\r');\r\n                } else if (ch === 't') {\r\n                    res.push('\\t');\r\n                } else if (ch === 'u') {\r\n                    res.push(string.substring(pos, pos + 4), 16);\r\n                    pos += 4;\r\n                } else {\r\n                    throw this._lexer.createParseException(token.line, token.column + pos - 2, \"Illegal string escape sequence\");\r\n                }\r\n            } else {\r\n                res.push(string[pos]);\r\n                pos += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    parse() {\r\n        if (this._lexer.testToken(this._lexer.tokenTypes.openBrace)) {\r\n            let jsonMap = new Map();\r\n\r\n            this._lexer.useToken(); // {\r\n            if (!this._lexer.testToken(this._lexer.tokenTypes.closeBrace)) {\r\n                while (true) {\r\n                    if (!this._lexer.testToken(this._lexer.tokenTypes.stringValue)) {\r\n                        throw this._createParseExceptionUnexpectedToken(\"string\");\r\n                    }\r\n                    var key = this.parseString(this._lexer.useToken());\r\n                    if (!this._lexer.testToken(this._lexer.tokenTypes.colon)) {\r\n                        throw createParseExceptionUnexpectedToken(\"colon\");\r\n                    }\r\n                    this._lexer.useToken(); // :\r\n                    console.log('key-' + key);\r\n                    jsonMap[key] = this.parse();\r\n\r\n                    if (this._lexer.testToken(this._lexer.tokenTypes.comma)) {\r\n                        this._lexer.useToken(); // ,\r\n                    } else if (this._lexer.testToken(this._lexer.tokenTypes.closeBrace)) {\r\n                        break;\r\n                    } else {\r\n                        throw createParseExceptionUnexpectedToken(\"comma or closing brace\");\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            lexer.useToken(); // }\r\n            return map;\r\n        }\r\n        return ' after processing';\r\n    }\r\n\r\n    static runParser(input, src) {\r\n        this._input = input;\r\n        this._src = src;\r\n        this._lexer = new JsonLexer(this._input, this._src);\r\n        this._instance = new JsonParser(this._lexer);\r\n        var result = this._instance.parse();\r\n\r\n        if (!this._lexer.testToken(this._lexer.tokenTypes.endOfFile)) {\r\n            throw this._createParseExceptionUnexpectedToken(\"end of file\");\r\n        }\r\n        return result;\r\n    }\r\n\r\n    static _createParseExceptionUnexpectedToken(expected) {\r\n        return this._lexer.createTokenParseException(this._lexer.useToken(), \"Expected \" + expected);\r\n    }\r\n}\r\n\r\nexport function runParser(input) {\r\n    JsonParser.runParser(input);\r\n}","export default class JsonToken {\r\n    constructor(type, match, line, column) {\r\n        this._type = type;\r\n        this._match = match;\r\n        this._line = line;\r\n        this._column = column;\r\n    }\r\n\r\n    get type() { return this._type }\r\n    set type(ntype) { this._type = ntype; }\r\n\r\n    get match() { return this._match; }\r\n    set match(nmatch) { this._match = nmatch; }\r\n\r\n    get line() { return this._line; }\r\n    set line(nline) { this._line = nline; }\r\n\r\n    get column() { return this._column; }\r\n    set column(ncolumn) { this._column = ncolumn; }\r\n}"],"sourceRoot":""}